# -*- coding: utf-8 -*-
"""Wall_e_V4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PfoOSnR45jK2kjvRjBxpz8Aai9HsMu--
"""

pip install biosppy

pip install wfdb

"""#principal"""

import os
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

# Ruta de las imágenes
ruta_imagenes = '"/content/drive/MyDrive/fotografias_JPG"'

# Ruta del modelo
ruta_modelo = '"/content/drive/MyDrive/modelo_IA/Wall_e_V3_model.h5"'

# Cargar el modelo
modelo = tf.keras.models.load_model(ruta_modelo)

# Obtener la lista de imágenes en la ruta
imagenes = os.listdir(ruta_imagenes)

# Crear una figura para mostrar las imágenes con etiquetas
fig, axes = plt.subplots(len(imagenes), 2, figsize=(8, 4 * len(imagenes)))

# Iterar sobre cada imagen
for i, imagen in enumerate(imagenes):
    # Comprobar si es un archivo de imagen PNG
    if imagen.endswith('.png'):
        # Cargar la imagen PNG del ECG
        ruta_imagen = os.path.join(ruta_imagenes, imagen)
        img = cv2.imread(ruta_imagen, cv2.IMREAD_GRAYSCALE)

        # Aplicar ecualización del histograma
        img_equalized = cv2.equalizeHist(img)

        # Aplicar filtro de mediana para eliminar el ruido
        img_filtered = cv2.medianBlur(img_equalized, 5)

        # Aplicar el algoritmo de realce de contraste adaptativo (CLAHE)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        img_enhanced = clahe.apply(img_filtered)

        # Redimensionar la imagen
        img_resized = cv2.resize(img_enhanced, (187, 1))

        # Agregar una dimensión adicional para representar los canales
        img_reshaped = np.expand_dims(img_resized, axis=-1)

        # Normalizar los valores de píxeles en el rango [0, 1]
        img_normalized = img_reshaped / 255.0

        # Hacer la predicción sobre la imagen procesada
        predicciones = modelo.predict(img_normalized)

        # Obtener la clase predicha (0: normal, 1: anormal)
        clase_predicha = np.argmax(predicciones)

        # Obtener la etiqueta correspondiente
        etiqueta = "Normal" if clase_predicha == 0 else "Anormal"

        # Mostrar la imagen original
        axes[i, 0].imshow(img, cmap='gray')
        axes[i, 0].set_title('Original')

        # Mostrar la imagen de extracción de características
        axes[i, 1].imshow(img_enhanced, cmap='gray')
        axes[i, 1].set_title('Características')

        # Establecer las etiquetas
        axes[i, 0].set_ylabel(etiqueta)
        axes[i, 1].set_ylabel(etiqueta)

# Ajustar los espacios entre las subfiguras
plt.tight_layout()

# Mostrar la figura
plt.show()